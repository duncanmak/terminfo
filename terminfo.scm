;;;
;;; terminfo.scm: Terminfo API for SCSH
;;;
;;; Copyright © 2007 Duncan Mak <duncan@ccs.neu.edu>
;;;

(define *current-terminal* '())
(define *terminfo-directories* '("/usr/share/terminfo"
                                 "/usr/share/misc/terminfo"))

(define-record-type terminal
  (make-terminal names booleans numbers strings)
  terminal?
  (names    terminal-names)
  (booleans terminal-booleans)
  (numbers  terminal-numbers)
  (strings  terminal-strings))

(define (terminfo-filename name)
  (let loop ((dirs *terminfo-directories*))
    (if (not (null? dirs))
        (let* ((basedir (car dirs))
               (initial (string-take name 1))
               (file    (path-list->file-name (list basedir initial name))))
          (cond ((file-not-exists? file)
                 (error "Cannot find terminfo named " name))
                ; TODO: returns only the relative path
                ((file-symlink? file) (read-symlink file))
                ((file-readable? file) file)
                (else (loop (cdr dirs))))))))

(define (read-byte . args)
  (let-optionals args ((s (current-input-port)))
    (let ((value (read-char s)))
      (if (eof-object? value)
          (error "invalid data")
          (char->ascii value)))))

(define (read-short . args)
  (let-optionals args ((s (current-input-port)))
    (let ((n (+ (read-byte s)
                (* 256 (read-byte s)))))
      (if (> n 32767)
          (- n 65536)
          n))))

(define (read-strings-and-split . args)
  (let-optionals args ((s (current-input-port)))
    (let loop ((char   (read-char s))
               (result '()))
      (if (or (eof-object? char) (zero? (char->ascii char)))
          ((infix-splitter "|") (reverse-list->string result))
          (loop (read-char s)
                (cons char result))))))

;;; Supports exactly *one* decimal point
(define (read-number . args)
  (let-optionals args ((s (current-input-port)))
    (let loop ((c      (peek-char s))
               (result '()))
      (case c
        ((#\.)
         (read-char) ; skip pass the .
         (string->number (reverse-list->string (cons (read-char) result))))
        ((#\>) ; this par
         (string->number (reverse-list->string result))
         )
            (else (loop (peek-char) (cons (read-char) result)))))))

(define (read-padding lines . args)
  (let-optionals args ((s (current-input-port)))
    (if (not (and (char=? #\$ (read-char s))
                  (char=? #\< (read-char s))))
        (error "Invalid input"))
    (let loop ((time  0)
               (force #f)
               (c     (peek-char s)))
      (cond
       ((eof-object? c) (error "Missing >"))
       ((char=? #\>  c) (list time force))
       ((char-digit? c) (loop (read-number s) force (read-char s)))
       ((char=? #\*  c) (loop (* time lines)  force (read-char s)))
       ((char=? #\/  c) (loop time            #t    (read-char s)))
       (else (error "Invalid padding specification"))))))

(define (baud-rate port direction)
  (define (handle-ext speed)
    (case speed
      ((exta) 19200)
      ((extb) 38400)
      (else   speed)))
  (let* ((info        (tty-info port))
         (input-rate  (tty-info:input-speed  info))
         (output-rate (tty-info:output-speed info)))
    (case direction
      ((input)  (handle-ext input-rate))
      ((output) (handle-ext output-rate)))))

(define (tputs string lines . args)
  (if (null? string) "")
  (with-current-ports
      (open-input-string string)
      (if (null? args) (current-output-port) (car args))
      (current-error-port)
    (lambda ()
      (let loop ((c (peek-char)))
        (cond
         ((eof-object? c))
         ((char=? #\$ c)
          (let* ((padding (read-padding lines))
                 (time    (car padding))
                 (force   (cdr padding))
                 (rate    (baud-rate (current-output-port) 'output)))
            (if (or force (eq? (xon-xoff) #t))
                (cond ((no-pad-char) (sleep (/ time 10000.0)))
                      (else
                       (do ((i 0 (+ i 1))) ((>= i (ceiling (/ (* rate time) 100000))))
                         (write (char-padding))
                         (loop (peek-char))))))))
         (else (write (read-char))
               (loop (peek-char))))))))

;;;
;;; See Table 7.3, _Unix_Curses_Explained_, p.101
;;;
(define (write-escaped-character)
  (if (not (char=? #\\ (read-char)))
      (error "Invalid input")
      (let ((c (read-char)))
        (case c
          ((#\E) (write (ascii->char 27)))
          ((#\e) (write (ascii->char 27)))
          ((#\n) (newline))
          ((#\l) (write (ascii->char 10)))
          ((#\r) (write (ascii->char 13)))
          ((#\t) (write (ascii->char 9)))
          ((#\b) (write (ascii->char 8)))
          ((#\f) (write (ascii->char 12)))
          ((#\s) (write #\space))
          ((#\,) (write #\,))
          ((#\0) (write (ascii->char 0)))
          ((#\\) (write #\\))
          ((#\^) (write #\^))
          ((#\:) (write #\:))
          (else  (error "Invalid character: " c))))))

;;; TODO
(define (write-control-character)
  (if (not (char=? #\^ (read-char)))
      (error "Invalid input")
      (write (read-char))))

(define (tparm s . args)
  (if (not (string? s)) "")
  (with-current-ports
      (open-input-string s)
      (open-output-string)
      (current-error-port)
    (lambda ()
      (let loop ((c (peek-char)))
        (cond
         ((eof-object? c)
          (get-output-string (current-output-port)))
         ((char=? #\\ c)
          (write-escaped-character)
          (loop (peek-char)))
         ((char=? #\^ c)
          (write-control-character)
          (loop (peek-char)))
         ((char=? #\% c)
          (write-parameterized-capability args)
          (loop (peek-char)))
         (else (write (read-char))
               (loop  (peek-char))))))))

(define (write-parameterized-capability args) #t)
;; (define (write-parameterized-capability args)
;;   (if (not (char=? #\% (read-char))) (error "Invalid string"))
;;   (letrec ((loop (lambda (c stk)
;;                    (case c
;;                      ((#\%) (write #\%)
;;                       (loop (read-char) stk))
;;                      ((#\+ #\- #\* #\% #\m)
;;                       (loop (read-char) (arithmatic c stk)))
;;                      ((#\{)
;;                       (loop (read-char) (push-integer-constant c stk)))
;;                      ((#\l)
;;                       (loop (read-char) (pop-string-addr+len c stk)))
;;                      ((#\i)
;;                       )

;; )))

;;            (arithmatic (lambda (c stk)
;;                          ()))
;;            (push-integer-constant (lambda (c stk)
;;                                )))
;;     (loop (read-char) '()))
;;   )

(define (load-terminfo name)
  (with-input-from-file name
    (lambda ()
      (let* ((magic         (read-short))
             (sznames       (read-short))
             (szbooleans    (read-short))
             (sznumbers     (read-short))
             (szstrings     (read-short))
             (szstringtable (read-short))
             (names         (read-strings-and-split))
             (booleans      (make-vector szbooleans #f))
             (numbers       (make-vector sznumbers -1))
             (strings       (make-vector szstrings -1))
             (stringtable   (make-string szstringtable)))
        (if (not (= magic #o432))
            (error "this file is invalid: " name))
        (do ((i 0 (+ i 1))) ((>= i szbooleans))
          (vector-set! booleans i (not (zero? (read-byte)))))
        (if (odd? (+ sznames szbooleans))
            (read-byte))
        (do ((i 0 (+ i 1))) ((>= i sznumbers))
          (vector-set! numbers i (read-short)))
        (do ((i 0 (+ i 1))) ((>= i szstrings))
          (vector-set! strings i (read-short)))
        (do ((i 0 (+ i 1))) ((>= i szstringtable))
          (string-set! stringtable i (read-char)))
        (do ((i 0 (+ i 1))) ((>= i szstrings))
          (if (positive? (vector-ref strings i))
              (let* ((start     (vector-ref strings i))
                     (end       (string-index stringtable (ascii->char 0)
                                              start szstringtable))
                     (new-value (substring stringtable start end)))
                (vector-set! strings i new-value))))
        (make-terminal names booleans numbers strings)))))

(define (setup-terminal . args)
  (let* ((term     (if (not (null? args))
                       (car args)
                       (getenv "TERM")))
         (filename (terminfo-filename term)))
    (set! *current-terminal* (load-terminfo filename))
    *current-terminal*))